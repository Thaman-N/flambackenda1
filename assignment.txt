# **QueueCTL - Backend Developer Internship Assignment**

### **Tech Stack:**

Your Choice - (Python / Go / Node.js / Java)

### **Submission:**

GitHub Repository (Public) + README

---

## üéØ **Objective**

Build a **CLI-based background job queue system** called `queuectl`.

This system should manage background jobs with worker processes, handle retries using exponential backoff, and maintain a **Dead Letter Queue (DLQ)** for permanently failed jobs.

---

## üß© **Problem Overview**

You need to implement a minimal, production-grade job queue system that supports:

- Enqueuing and managing background jobs
- Running multiple worker processes
- Retrying failed jobs automatically with exponential backoff
- Moving jobs to a **Dead Letter Queue** after exhausting retries
- Persistent job storage across restarts
- All operations accessible through a **CLI interface**

---

## üì¶ **Job Specification**

Each job must contain at least the following fields:

```json
{
  "id": "unique-job-id",
  "command": "echo 'Hello World'",
  "state": "pending",
  "attempts": 0,
  "max_retries": 3,
  "created_at": "2025-11-04T10:30:00Z",
  "updated_at": "2025-11-04T10:30:00Z"
}
```

---

## üîÑ **Job Lifecycle**

| **State** | **Description** |
| --- | --- |
| `pending` | Waiting to be picked up by a worker |
| `processing` | Currently being executed |
| `completed` | Successfully executed |
| `failed` | Failed, but retryable |
| `dead` | Permanently failed (moved to DLQ) |

---

## üíª **CLI Commands**

Your tool must support the following commands:

| **Category** | **Command Example** | **Description** |
| --- | --- | --- |
| **Enqueue** | `queuectl enqueue '{"id":"job1","command":"sleep 2"}'` | Add a new job to the queue |
| **Workers** | `queuectl worker start --count 3` | Start one or more workers |
|  | `queuectl worker stop` | Stop running workers gracefully |
| **Status** | `queuectl status` | Show summary of all job states & active workers |
| **List Jobs** | `queuectl list --state pending` | List jobs by state |
| **DLQ** | `queuectl dlq list` / `queuectl dlq retry job1` | View or retry DLQ jobs |
| **Config** | `queuectl config set max-retries 3` | Manage configuration (retry, backoff, etc.) |

---

## ‚öôÔ∏è **System Requirements**

1. **Job Execution**
    - Each worker must execute the specified command (e.g. `sleep 2`, `echo hello`, etc.)
    - Exit codes should determine success or failure.
    - Commands that fail or are not found should trigger retries.
2. **Retry & Backoff**
    - Failed jobs retry automatically.
    - Implement exponential backoff:
        
        `delay = base ^ attempts` seconds
        
    - Move to DLQ after `max_retries`.
3. **Persistence**
    - Job data must persist across restarts.
    - Use file storage (JSON) or SQLite/embedded DB or anything which you think is best for this usecase.
4. **Worker Management**
    - Multiple workers can process jobs in parallel.
    - Prevent duplicate processing (locking required).
    - Implement graceful shutdown (finish current job before exit).
5. **Configuration**
    - Allow configurable retry count and backoff base via CLI.

---

## üß™ **Expected Test Scenarios**

Candidates are expected to ensure the following:

1. Basic job completes successfully.
2. Failed job retries with backoff and moves to DLQ.
3. Multiple workers process jobs without overlap.
4. Invalid commands fail gracefully.
5. Job data survives restart.

---

## üìã **Must-Have Deliverables**

Your submission **must include**:

- ‚úÖ Working CLI application (`queuectl`)
- ‚úÖ Persistent job storage
- ‚úÖ Multiple worker support
- ‚úÖ Retry mechanism with exponential backoff
- ‚úÖ Dead Letter Queue
- ‚úÖ Configuration management
- ‚úÖ Clean CLI interface (commands & help texts)
- ‚úÖ Comprehensive `README.md`
- ‚úÖ Code structured with clear separation of concerns
- ‚úÖ At least minimal testing or script to validate core flows

---

## üìò **README Expectations**

Your `README.md` should cover:

1. **Setup Instructions** ‚Äî How to run locally
2. **Usage Examples** ‚Äî CLI commands with example outputs
3. **Architecture Overview** ‚Äî Job lifecycle, data persistence, worker logic
4. **Assumptions & Trade-offs** ‚Äî Decisions made, any simplifications
5. **Testing Instructions** ‚Äî How to verify functionality

---

## üìä **Evaluation Criteria**

| **Criteria** | **Weight** | **Description** |
| --- | --- | --- |
| **Functionality** | 40% | Core features (enqueue, worker, retry, DLQ) |
| **Code Quality** | 20% | Structure, readability, maintainability |
| **Robustness** | 20% | Handles edge cases and concurrency safely |
| **Documentation** | 10% | Clear setup and usage instructions |
| **Testing** | 10% | Demonstrates correctness and reliability |

---

## üåü **Bonus Features (Optional)**

Extra credit will be given for:

- Job timeout handling
- Job priority queues
- Scheduled/delayed jobs (`run_at`)
- Job output logging
- Metrics or execution stats
- Minimal web dashboard for monitoring

---

## ‚ö†Ô∏è **Disqualification / Common Mistakes**

- Missing retry or DLQ functionality
- Race conditions or duplicate job execution
- Non-persistent data (jobs lost on restart)
- Hardcoded configuration values
- Unclear or missing README

---

## üßæ **Submission**

1. Push your complete solution to a **public GitHub repository**.
2. Include a **README.md** as per above.
3. Record a working cli demo (upload to drive and provide link in [README.md](http://README.md))
4. Optional: include a short **architecture or design.md** file.
5. Share the repository link for review.